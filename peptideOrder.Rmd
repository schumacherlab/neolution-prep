---
title: "## INSERT PROJECT TITLE ## - neo-antigen screen"
author: "Lorenzo Fanchi"
date: "`r format(Sys.Date(), '%d-%b-%Y')`"
output: 
  html_document: 
    theme: cerulean
    toc: yes
    toc_depth: 5
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

setwd('~/projects/## PROJECT DIR ##')

source('runConfig.R')
source('helperFunctions.R')
```

<link href="style.css" rel="stylesheet" type="text/css" />

<br>

#### Introduction

This document contains the order and set-up lists of the epitopes for the ## PROJECT TITLE ## project.

<br>

#### Methods summary

Samples were sequenced by GCF at the Netherlands Cancer Institute, data can be found at:  

* [GCF DNA repository link](### INSERT LINK HERE ###)  
* [GCF RNA repository link](### INSERT LINK HERE ###)  

The GCF performed the following:  

1. DNA (exome) and RNA sequencing  
2. variant calling using the somaticSniper/somaticIndelCaller (GATK) pipeline (alignment with bwa)  
3. generation of VCF files containing SNVs and indels  

I further processed the resulting VCF files and RNAseq data by:  

1. annotating identified variants with 'expression of mutant allele' data  
2. generating variant contexts for all expressed variants (or variants without expression data) using the varcontext tool (branch: #####, commit: #####)  
3. aligning RNAseq data using STAR & salmon, generating TPM values  
4. annotating varcontext output with gene-level expression data  

Point 1 was done by performing pileups at the SNV genomic loci in the aligned RNAseq BAM files. For a given SNV locus, a minimum of 5 or more reads for either the germline or the mutant base were required for further analysis. In case this requirement was met, expression of the mutant allele was deemed present if > 1 read containing the mutant base was found. In case minimum read requirement was not met, the SNV was annotated with NA.  

Epitopes were predicted using in-house epitope prediction pipeline, using random forest prediction for probability of presentation (branch: #####, commit: #####)  

<br>

* Transcript effects of called variants were determined by our in-house 'varcontext' tool with the following parameters:  

| parameter                 						 	| value             |
|-----------------------------------------|-------------------|
| _Ensembl version_            						|    81 (GRCh38)    |
| _Mutant allele expression filter_				|			TRUE					|
| _Canonical transcripts only_ 						|      FALSE        |

<br>

* The following default filtering parameters were used for epitope selection:  

| parameter                    	| value                      														|
|-------------------------------|-------------------------------------------------------|
| _netMHCpan rank cutoff_      	|     `r runOptions$neolution$rank_cutoff`  			    	|
| _netChop processing cutoff_  	|	    `r runOptions$neolution$processing_cutoff`  			|
| _Model cutoff_								|			>= `r runOptions$neolution$model_cutoff`					|
| _RNA expression cutoff_      	|     > `r runOptions$neolution$expression_cutoff`  		|
|	_Random forest model_					|			`r runOptions$neolution$random_forest_model`			|
| _Selfsim filter_             	|    `r runOptions$neolution$selfsim_filter`      			|
| _Selfsim mode_            		|    `r runOptions$neolution$selfsim_filter_mode`  			|
| _Selflist_		            		|    `r runOptions$neolution$selflist`						 			|

<br>

#### Sample information

```{r variant_snpEff_info}
snpeff_output = list.files(path = '4_snpEff',
                           pattern = 'genes\\.txt',
                           full.names = T)
snpeff_output = snpeff_output[!grepl(pattern = 'snps', x = snpeff_output, fixed = TRUE)]

sample_info = fread('sample_info.tsv')
sample_info = sample_info[naturalorder(sample_info$patient_id)]

effects_table = rbindlist(lapply(snpeff_output,
                                 function(path) {
                                   data = fread(path, skip = 1)
                                   
                                   data.table(patient_id = sample_info[dna_data_prefix == gsub(pattern = regexPatterns$seqdata_prefix,
                                                                                               replacement = '',
                                                                                               x = basename(path),
                                                                                               perl = T),
                                                                       patient_id],
                                              syn_coding_variants = sum(data$variants_effect_synonymous_variant),
                                              non_syn_coding_variants = sum(data$variants_effect_missense_variant),
                                              stop_gained_variants = sum(data$variants_effect_stop_gained),
                                              inframe_insertion_variants = sum(data$variant_effect_inframe_insertion),
                                              frameshift_variants = sum(data$variants_effect_frameshift_variant))
                                 }))

effects_table = effects_table[naturalorder(effects_table$patient_id)]

pander(sample_info, split.table = Inf, missing = '')

pander(effects_table, split.table = Inf)
```

```{r load_prediction_data, message = FALSE}
# parse data
project_predictions = parseEpitopePredictions(path = '3_neolution/predictions_output',
                                              pattern = '_epitopes_no_selfsim\\.csv')

# parse unfiltered data to calculate some stats
project_predictions_unfiltered = parseEpitopePredictions(path = '3_neolution/predictions_output', 
                                                         pattern = '_epitopes_unfiltered\\.csv')

# take subsets based on epitopes per non-syn mutations + indels
project_predictions_subset = applyCutoffs(predictions = project_predictions,
                                          model = runOptions$neolution$model_cutoff,
                                          expression = runOptions$neolution$expression_cutoff,
                                          selfsim = runOptions$neolution$selfsim_filter)

# exclude alleles
project_predictions_subset = project_predictions_subset[!grepl(pattern = regexPatterns$allele_exclusion, x = names(project_predictions_subset))]
project_predictions_unfiltered = project_predictions_unfiltered[!grepl(pattern = regexPatterns$allele_exclusion, x = names(project_predictions_unfiltered))]

# split by xmer
project_predictions_by_xmer = prepareEpitopeLists(list_of_predictions = project_predictions_subset)
```

```{r prepare_order_and_setup_lists}
# bind all together for order list
all_predictions = rbindlist(project_predictions_by_xmer)
all_predictions = all_predictions[naturalorder(patient_id)]
setkey(x = all_predictions, xmer, tumor_peptide_resin)

# take subsets for individual patients for combi-coding setup lists
predictions_by_patient = setNames(object = lapply(sample_info$dna_data_prefix,
                                                  function(prefix) {
                                                    data_subset = all_predictions[sample_prefix == prefix]
                                                    
                                                    data_unique = unique(x = data_subset,
                                                                         by = c('hla_allele', 'tumor_peptide'))
                                                    
                                                    setkey(x = data_unique, xmer, hla_allele)
                                                    return(data_unique)
                                                  }),
                                  nm = sample_info$patient_id)

# prepare unfiltered predictions to generate some stats
all_predictions_unfiltered = rbindlist(project_predictions_unfiltered)
setnames(x = all_predictions_unfiltered,
         old = grep('affinity|percentile_rank', names(all_predictions_unfiltered), value = T),
         new = c('tumor_affinity_nM', 'tumor_affinity_rank', 'normal_affinity_nM', 'normal_affinity_rank'))
all_predictions_unfiltered_by_patient = setNames(object = lapply(sample_info$patient_id,
                                                                 function(id) {
                                                                   data_subset = all_predictions_unfiltered[patient_id == id]
                                                                   
                                                                   return(data_subset)
                                                                 }),
                                                 nm = sample_info$patient_id)
```

<br>

#### Predicted epitopes summary

```{r generate_prediction_summary, results = 'hide'}
prediction_table = merge(x = data.table(patient_id = names(sapply(predictions_by_patient, nrow)),
                                        alleles_included = sapply(names(all_predictions_unfiltered_by_patient),
                                                                  function(id) {
                                                                    length(all_predictions_unfiltered_by_patient[[id]][, unique(hla_allele)])
                                                                  }),
                                        total_epitopes_predicted = sapply(all_predictions_unfiltered_by_patient, nrow),
                                        selected_epitopes_predicted = sapply(predictions_by_patient, nrow)),
                         y = effects_table[, -c('syn_coding_variants'), with = F],
                         by = 'patient_id')
prediction_table = prediction_table[naturalorder(patient_id)]
prediction_table[, total_epitope_yield_rate_per_allele := round(x = total_epitopes_predicted / non_syn_coding_variants / alleles_included, digits = 0)]
prediction_table[, selected_epitope_yield_rate_per_allele := round(x = selected_epitopes_predicted / non_syn_coding_variants / alleles_included, digits = 2)]
setcolorder(x = prediction_table,
            neworder = c('patient_id', 'alleles_included', 'total_epitopes_predicted', 'total_epitope_yield_rate_per_allele', 'selected_epitopes_predicted', 'selected_epitope_yield_rate_per_allele', 
                         setdiff(x = names(prediction_table),
                                 y = c('patient_id', 'alleles_included', 'total_epitopes_predicted', 'total_epitope_yield_rate_per_allele', 'selected_epitopes_predicted', 'selected_epitope_yield_rate_per_allele'))))
```

```{r pander_prediction_summary}
pander(prediction_table, split.table = 200, split.cells = 20, use.hyphening = TRUE)
```

<br>

__Total number of unique selected epitopes: `r nrow(unique(all_predictions, by = 'tumor_peptide'))`__  

<br>

#### Predicted epitopes - __All patients__ - master order list (unique peptides)
- __epitopes are sorted by xmer and subsequently by resin__
```{r pander_order_list}
# peptide synth facility list: list all unique epitopes, sorted by xmer and last residue
pander(x = unique(x = subset(x = all_predictions,
                             select = names(all_predictions) %nin% c('sample_prefix', 'hla_allele')),
                  by = 'tumor_peptide'),
       split.table = 200)
```

<br>

#### Predicted epitopes - __Individual patients__ - list for combi-coding setups
- __epitopes predicted to bind to multiple alleles are shown in bold__
- __epitopes are sorted by xmer first, then by hla\_allele__
```{r pander_setup_lists, results = 'asis'}
# multimer combi-coding setup list: all epitopes and alleles, sorted by xmer and hla_allele
panderOptions('knitr.auto.asis', FALSE)

for (i in 1:length(predictions_by_patient)) {
  cat('\n#####', names(predictions_by_patient)[i], '\n')
  
  # highlight duplicates (epitopes binding to multiple alleles)
  if (anyDuplicated(predictions_by_patient[[i]]$tumor_peptide)) {
    emphasize.strong.rows(unique(c(which(duplicated(predictions_by_patient[[i]]$tumor_peptide, fromLast = FALSE)),
                                   which(duplicated(predictions_by_patient[[i]]$tumor_peptide, fromLast = TRUE)))))	
  }
  pander(predictions_by_patient[[i]][, -c('sample_prefix', 'tumor_peptide_trunc', 'tumor_peptide_resin'), with = FALSE], split.table = 200)	
}
```

